<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>AI Flight Planner — Day 4–5</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <link href="https://unpkg.com/maplibre-gl@3.6.2/dist/maplibre-gl.css" rel="stylesheet" />
  <script src="https://unpkg.com/maplibre-gl@3.6.2/dist/maplibre-gl.js"></script>
  <style>
    :root { --bg:#0e1320; --fg:#e6edf3; --muted:#9fb0c3; --accent:#4cc3ff; }
    *{box-sizing:border-box}
    body{margin:0;font-family:system-ui,Segoe UI,Roboto,Inter;background:var(--bg);color:var(--fg)}
    header{padding:12px 16px;border-bottom:1px solid #1c2333;display:flex;gap:12px;align-items:center}
    header h1{font-size:16px;margin:0;font-weight:600}
    #app{display:grid;grid-template-columns:360px 1fr;min-height:calc(100vh - 50px)}
    #left{border-right:1px solid #1c2333;padding:14px;overflow:auto}
    #right{position:relative}
    #map{position:absolute;inset:0}
    .card{background:#0f172a;border:1px solid #1c2333;border-radius:12px;padding:12px;margin-bottom:12px}
    .row{display:flex;gap:8px;align-items:center;flex-wrap:wrap}
    textarea,input{width:100%;background:#0b1220;color:var(--fg);border:1px solid #1c2333;border-radius:8px;padding:10px}
    button{background:var(--accent);color:#001622;border:0;border-radius:10px;padding:10px 14px;font-weight:600;cursor:pointer}
    button.ghost{background:#0b1220;color:var(--fg);border:1px solid #26324a}
    .small{font-size:12px;color:var(--muted)}
    .kvs{font-family:ui-monospace, Menlo, Consolas, monospace; font-size:12px; white-space:pre-wrap}
    .hr{height:1px;background:#1c2333;margin:10px 0}
    .ok{color:#2ee6a6}.warn{color:#ffb86b}.bad{color:#ff6b6b}
    .badge{position:absolute;right:12px;top:12px;background:#111827c0;padding:6px 10px;border:1px solid #26324a;border-radius:8px}
  </style>
</head>
<body>
<header>
  <h1>AI Flight Planner — Day 4–5</h1>
  <span class="badge" id="demoBadge" style="display:none">Demo mode (cached)</span>
</header>

<div id="app">
  <section id="left">
    <div class="card">
      <strong>Mission Description</strong>
      <textarea id="mission" placeholder="e.g. Fly to mountain lake, then survey the eastern shore at 120m AGL"></textarea>
      <div class="row" style="margin-top:8px">
        <button id="btnParse">Parse with AI</button>
        <button class="ghost" id="btnSample">Use Day-4 Test</button>
      </div>
      <div class="small" style="margin-top:6px">
        Day-4 target: “Fly to mountain lake” → AI extracts coords & a label.
      </div>
      <div class="hr"></div>
      <div><strong>Parsed Output</strong></div>
      <div id="aiOut" class="kvs"></div>
      <div class="hr"></div>
      <div><strong>Validation</strong></div>
      <div id="validate" class="kvs"></div>
    </div>

    <div class="card">
      <strong>Parsed Mission (advanced)</strong>
      <div id="advOut" class="kvs"></div>
    </div>


    <div class="card">
      <strong>Route & Safety</strong>
      <div class="small">With terrain on, we check clearance along the path.</div>
      <div class="row" style="margin-top:8px">
        <input id="altitude" placeholder="Cruise Altitude AGL (m), e.g. 120" />
        <input id="buffer" placeholder="Safety Buffer (m), e.g. 30" />
      </div>
      <div class="row" style="margin-top:8px">
        <button id="btnClick">Click Start/End</button>
        <label class="small"><input type="checkbox" id="chkRTH" checked /> Return to Home</label>
        <button id="btnRoute">Draw Route</button>
      </div>
      <div id="safety" class="small"></div>
    </div>

    <div class="card">
      <strong>Battery & Range (VTOL)</strong>
      <div class="small">Uses vehicle defaults from config. Adjust as needed.</div>
      <div class="row" style="margin-top:8px">
        <input id="payloadKg" placeholder="Payload (kg), e.g. 1.0" />
        <input id="windMS" placeholder="Head/Tailwind (m/s, +head -tail), e.g. 2" />
      </div>
      <div class="row" style="margin-top:8px">
        <button id="btnEstimate">Estimate Battery</button>
      </div>
      <div id="batteryOut" class="kvs"></div>
    </div>

    <div class="card">
      <strong>Route Options (Day 8)</strong>
      <div class="row" style="margin-top:8px">
        <button id="btnRoutes">Generate Routes</button>
        <button class="ghost" id="btnPickShortest">Use Shortest</button>
        <button class="ghost" id="btnPickSafe">Use Safest</button>
        <button class="ghost" id="btnPickEfficient">Use Efficient</button>
      </div>
      <div id="routesTable" class="kvs" style="margin-top:8px"></div>
    </div>

    <div class="card">
      <strong>Safety Checklist (Day 9)</strong>
      <div class="row" style="margin-top:8px">
        <input id="minAlt" placeholder="Min altitude AGL (m), e.g. 60" />
        <button id="btnCheck">Run Checks</button>
      </div>
      <div id="safetyPanel" class="kvs" style="margin-top:8px"></div>
    </div>




    <div class="card">
      <strong>Notes</strong>
      <div class="small">
        • OpenAI via backend (key hidden).<br/>
        • MapTiler key restricted by domain; 3D terrain + hillshade + buildings.<br/>
        • Demo fallback when API is unavailable.
      </div>
    </div>
  </section>

  <section id="right"><div id="map"></div></section>
</div>

<script>
const $ = id => document.getElementById(id);
const state = { waypoints: [], config: null };
const SYSTEM_PROMPT = `You extract geographic targets from free-text mission descriptions.
Return strict JSON:
{"targets":[{"name":"label","lat":12.34,"lon":56.78}, ...]}
- If coords not present, infer the single best place.
- Decimal degrees only; lat[-90..90], lon[-180..180].`;

/* -------- boot -------- */
(async function boot(){
  // fetch config (includes map style + whether terrain is enabled)
  const r = await fetch('/api/config');
  state.config = await r.json();
  bootMap();
})();

/* -------- Map -------- */
let map;
function bootMap(){
  const styleUrl = state.config.mapStyleUrl; // already includes key & chosen style
  map = new maplibregl.Map({
    container: 'map',
    style: styleUrl,
    center: [127.0, 37.5], zoom: 6, pitch: 60, bearing: -30
  });
  map.addControl(new maplibregl.NavigationControl(), 'top-right');

  map.on('load', () => {
    if (state.config.terrainDemUrl) {
      if (!map.getSource('terrain')) {
        map.addSource('terrain', { type:'raster-dem', url: state.config.terrainDemUrl, tileSize:256 });
      }
      map.setTerrain({ source:'terrain', exaggeration: 1.5 });

      // hillshade (visual relief)
      if (!map.getLayer('hillshade')) {
        map.addLayer({ id:'hillshade', type:'hillshade', source:'terrain',
          paint:{ 'hillshade-exaggeration': 0.6 } }, undefined);
      }
    }

    // 3D buildings if style exposes OpenMapTiles 'building'
    if (!map.getLayer('3d-buildings')) {
      try {
        map.addLayer({
          id:'3d-buildings',
          type:'fill-extrusion',
          source:'openmaptiles',
          'source-layer':'building',
          minzoom:14,
          paint:{
            'fill-extrusion-color':'#d1d5db',
            'fill-extrusion-height':['coalesce',['get','height'],12],
            'fill-extrusion-base':['coalesce',['get','min_height'],0],
            'fill-extrusion-opacity':0.8
          }
        });
      } catch(_) {/* style may not have openmaptiles; ignore */}
    }
  });
}
function clearRouteOptionLayers(){
  for(const id of ['opt-shortest','opt-safest','opt-efficient']){
    if(map.getLayer(id)) map.removeLayer(id);
    if(map.getSource(id)) map.removeSource(id);
  }
}

function drawCandidate(id, coords, color){
  const geo = { type:'Feature', geometry:{type:'LineString', coordinates:coords} };
  const src = `opt-${id}`;
  if(map.getLayer(src)) { map.removeLayer(src); map.removeSource(src); }
  map.addSource(src,{type:'geojson',data:geo});
  map.addLayer({id:src,type:'line',source:src,paint:{'line-width':4,'line-color':color}});
}

$('btnRoutes').onclick = ()=>{
  if(!state.waypoints || state.waypoints.length<2){
    alert('Need at least Start and End (click map or parse text).');
    return;
  }
  const cruise = parseFloat($('altitude').value || '120');
  const buffer = parseFloat($('buffer').value || '30');
  const opts = routeCandidatesFromWaypoints(state.waypoints,{cruise,buffer});
  state._candidates = opts;

  clearRouteOptionLayers();
  for(const r of opts) drawCandidate(r.id, r.coords, r.color);

  // render mini table
  const lines = [
    'id        dist   minClr  bad/warn  cruiseUsed',
    ...opts.map(r => `${r.id.padEnd(9)} ${kmToStr(r.stats.distKm).padEnd(6)} ${(r.stats.minClear??'-').toString().padEnd(6)}  ${String(r.stats.bad).padStart(2)}/${String(r.stats.warn).padEnd(2)}   ${r.stats.cruiseUsed}`)
  ];
  $('routesTable').textContent = lines.join('\n');
};

$('btnCheck').onclick = ()=>{
  const out=[];
  const minAlt = parseFloat($('minAlt').value || '0');
  const cruise = parseFloat($('altitude').value || '120');
  const buffer = parseFloat($('buffer').value || '30');

  if(minAlt && cruise < minAlt){
    out.push(`❌ Cruise altitude ${cruise}m < minimum ${minAlt}m`);
  }else if(minAlt){ out.push(`✓ Min altitude satisfied: ${cruise}m ≥ ${minAlt}m`); }

  if(!state.waypoints || state.waypoints.length<2){
    out.push('❌ Need route waypoints'); $('safetyPanel').textContent = out.join('\n'); return;
  }

  // Terrain pass along current waypoints
  const coords = state.waypoints.map(w=>[w.lon,w.lat]);
  const samples = lineSample(coords, 80);
  const stats = clearanceStats(samples, cruise, buffer);
  if(stats.bad>0) out.push(`⚠️ Low-clearance segments: ${stats.bad} (min clr ${stats.minClear}m)`);
  else out.push(`✓ Clearance OK. Min ${stats.minClear}m`);

  // RTH (if 3 points with last == first)
  const isRTH = state.waypoints.length>=3 &&
                Math.abs(state.waypoints[0].lat - state.waypoints.at(-1).lat)<1e-6 &&
                Math.abs(state.waypoints[0].lon - state.waypoints.at(-1).lon)<1e-6;
  out.push(isRTH ? '✓ RTH present' : '⚠️ No Return-to-Home waypoint');

  // Basic low-battery trigger using Day-7 calc (re-use estimator)
  // (quick recompute using default inputs)
  const VEH = VEHICLE || {cruise_kmh:95, nominal_flight_time_hr:4};
  const distKm = routeDistanceKm(state.waypoints);
  const basePct = (VEH.nominal_flight_time_hr>0) ? (distKm / (VEH.cruise_kmh*VEH.nominal_flight_time_hr)) : 1;
  const used = Math.min(1, basePct);
  if(used > 0.8) out.push(`⚠️ Battery usage high: ${(used*100).toFixed(0)}% (consider RTH earlier)`); else out.push('✓ Battery margin OK');

  $('safetyPanel').textContent = out.join('\n');
};


// pickers
$('btnPickShortest').onclick = ()=>pickCandidate('shortest');
$('btnPickSafe').onclick = ()=>pickCandidate('safest');
$('btnPickEfficient').onclick = ()=>pickCandidate('efficient');

function pickCandidate(id){
  const c = (state._candidates||[]).find(x=>x.id===id);
  if(!c) return alert('Generate routes first.');
  // update active waypoints to chosen coords (keeps downstream logic simple)
  state.waypoints = wpsFromCoords(c.coords);
  $('aiOut').textContent = JSON.stringify(state.waypoints,null,2);
  $('validate').textContent = `✅ Using candidate: ${id}`;
  // optionally redraw Day-5 safety route using existing “Draw Route” button
}


let clickMode = false;
let clickPts = []; // [{lat,lon,name}]

$('btnClick').onclick = () => {
  clickMode = !clickMode;
  $('btnClick').textContent = clickMode ? 'Click: ON (choose Start/End)' : 'Click Start/End';
  if (!clickMode) return;
  clickPts = [];
  if (map) {
    map.getCanvas().style.cursor = 'crosshair';
    map.once('click', onClickStart);
  }
};

function onClickStart(e){
  clickPts.push({ name:'Start', lat:e.lngLat.lat, lon:e.lngLat.lng });
  map.once('click', onClickEnd);
}
function onClickEnd(e){
  clickPts.push({ name:'End', lat:e.lngLat.lat, lon:e.lngLat.lng });
  map.getCanvas().style.cursor = '';
  clickMode = false; $('btnClick').textContent = 'Click Start/End';

  // Build waypoints with optional RTH
  const rth = $('chkRTH').checked;
  state.waypoints = rth ? [clickPts[0], clickPts[1], { ...clickPts[0], name:'RTH' }] : [...clickPts];

  // Show in left panel
  $('aiOut').textContent = JSON.stringify(state.waypoints, null, 2);
  $('validate').textContent = '✅ Waypoints from clicks.';
  flyTo(state.waypoints[0]);
}
let VEHICLE = null;
(async ()=>{  // grab vehicle defaults on boot
  const conf = await fetch('/api/config').then(r=>r.json());
  VEHICLE = conf.vehicle || null;
})();

$('btnEstimate').onclick = ()=>{
  if(!VEHICLE){ $('batteryOut').textContent = "No vehicle config."; return; }
  const payload = parseFloat($('payloadKg').value || "0");
  const windMS  = parseFloat($('windMS').value || "0");

  const cruise = VEHICLE.cruise_kmh || 95;
  const effCruise = Math.max(5, cruise - (windMS*3.6)); // simple head/tail effect
  const nominalRange = cruise * (VEHICLE.nominal_flight_time_hr || 4); // km

  const dist = routeDistanceKm(state.waypoints); // km
  const basePct = nominalRange>0 ? (dist / nominalRange) : 1;

  // penalties
  const payloadPenalty = Math.max(0, payload) * 0.05; // +5% per kg
  const climbPenalty = 0; // TODO: compute from terrain samples
  const totalPct = Math.min(1, basePct * (1 + payloadPenalty + climbPenalty));

  const timeHr = effCruise>0 ? (dist / effCruise) : 0;
  const estRemaining = Math.max(0, 1 - totalPct);

  $('batteryOut').textContent =
`Vehicle: ${VEHICLE.type} | Cruise ${cruise} km/h | Nominal ${VEHICLE.nominal_flight_time_hr} h
Route distance: ${dist.toFixed(1)} km
Effective cruise (wind): ${effCruise.toFixed(1)} km/h
Flight time est: ${(timeHr*60).toFixed(0)} min
Battery used: ${(totalPct*100).toFixed(0)}%   Remaining: ${(estRemaining*100).toFixed(0)}%`;
};

function kmToStr(km){ return km.toFixed(1) + " km"; }

function lineSample(coords, n=80){
  if(coords.length<2) return [];
  const out=[];
  for(let i=0;i<n;i++){
    const t=i/(n-1);
    const L=coords.length-1, s=t*L, k=Math.min(L-1, Math.floor(s)), u=s-k;
    const a=coords[k], b=coords[k+1];
    out.push([ a[0]+(b[0]-a[0])*u, a[1]+(b[1]-a[1])*u ]);
  }
  return out;
}

function clearanceStats(samples, cruise, buffer){
  const supports = typeof map.queryTerrainElevation==='function' && map.getTerrain();
  let bad=0, warn=0, minClear=Infinity;
  for(let i=0;i<samples.length;i++){
    const p = samples[i];
    let elev=0;
    if(supports) elev = map.queryTerrainElevation({lng:p[0],lat:p[1]}) ?? 0;
    const cl = cruise - elev;
    minClear = Math.min(minClear, cl);
    if(!supports) continue;
    if(cl < buffer) bad++; else if(cl < buffer*1.5) warn++;
  }
  return {bad,warn,minClear:isFinite(minClear)?Math.round(minClear):null};
}

/* -------- Helpers -------- */
function fromTextHeuristics(s){
  const out=[]; let m;
  const decRe=/([-+]?(\d{1,2}(?:\.\d+)?))\s*[, ]\s*([-+]?(?:1[0-7]\d|\d{1,2})(?:\.\d+)?)/g;
  while((m=decRe.exec(s))!==null){ const lat=+m[1], lon=+m[3]; if(Math.abs(lat)<=90&&Math.abs(lon)<=180) out.push({name:'coord',lat,lon}); }
  const gRe=/@(-?\d{1,2}\.\d+),(-?1?\d{1,2}\.\d+)/g;
  while((m=gRe.exec(s))!==null) out.push({name:'map-link',lat:+m[1],lon:+m[2]});
  const dms=/(\d{1,3})[°\s]\s*(\d{1,2})['\s]\s*(\d{1,2}(?:\.\d+)?)"?\s*([NS])[, ]+\s*(\d{1,3})[°\s]\s*(\d{1,2})['\s]\s*(\d{1,2}(?:\.\d+)?)"?\s*([EW])/ig;
  while((m=dms.exec(s))!==null){
    const lat=(+m[1]+m[2]/60+m[3]/3600)*(m[4].toUpperCase()==='S'?-1:1);
    const lon=(+m[5]+m[6]/60+m[7]/3600)*(m[8].toUpperCase()==='W'?-1:1);
    out.push({name:'dms',lat,lon});
  }
  return out;
}
function validateWaypoints(list){
  const msgs=[], ok=[], seen=new Set();
  for(const p of list||[]){
    const lat=+p.lat, lon=+p.lon;
    if(!Number.isFinite(lat)||!Number.isFinite(lon)){ msgs.push(`❌ Non-numeric: ${JSON.stringify(p)}`); continue; }
    if(Math.abs(lat)>90||Math.abs(lon)>180){ msgs.push(`❌ Out of range: ${lat}, ${lon}`); continue; }
    const key=lat.toFixed(6)+","+lon.toFixed(6);
    if(seen.has(key)){ msgs.push(`⚠️ Duplicate ignored: ${key}`); continue; }
    seen.add(key); ok.push({name:p.name||"wp",lat,lon});
  }
  return {ok,msgs};
}
function flyTo(p){ map && map.flyTo({center:[p.lon,p.lat], zoom: 10}); }

/* -------- Backend call with retry -------- */
async function callParseAPI(payload, maxRetries=2){
  let attempt=0;
  while(true){
    const r = await fetch('/api/parse', {
      method:'POST', headers:{'Content-Type':'application/json'},
      body: JSON.stringify(payload)
    });
    if(r.status!==429) return r;
    attempt++; if(attempt>maxRetries) return r;
    const retryAfter=parseFloat(r.headers.get('retry-after')||'0');
    await new Promise(res=>setTimeout(res, (retryAfter?retryAfter*1000:1500*attempt)));
  }
}
function havDist(a,b){ // km, simple haversine
  const R=6371, toRad=x=>x*Math.PI/180;
  const dLat=toRad(b.lat-a.lat), dLon=toRad(b.lon-a.lon);
  const s1=Math.sin(dLat/2)**2 + Math.cos(toRad(a.lat))*Math.cos(toRad(b.lat))*Math.sin(dLon/2)**2;
  return 2*R*Math.asin(Math.sqrt(s1));
}
function routeDistanceKm(pts){
  if(!pts || pts.length<2) return 0;
  let d=0; for(let i=0;i<pts.length-1;i++) d+=havDist(pts[i],pts[i+1]); return d;
}


function routeCandidatesFromWaypoints(wps, opts){
  const { cruise=120, buffer=30 } = opts||{};
  if(!wps || wps.length<2) return [];

  // base polyline (straight segments)
  const coords = wps.map(w=>[w.lon,w.lat]);

  // 1) shortest = the straight baseline
  const shortest = { id:'shortest', label:'Shortest', color:'#60a5fa', coords:[...coords] };

  // 2) safest (terrain-aware): same geometry but suggests higher cruise if needed
  // (Detouring would require a pathfinder; this MVP bumps cruise for stats)
  const safe = { id:'safest', label:'Safest', color:'#34d399', coords:[...coords], cruiseBoost: true };

  // 3) efficient: favors fewer climbs (MVP = slight smoothing)
  const efficient = { id:'efficient', label:'Efficient', color:'#f59e0b', coords:smoothCoords(coords, 0.25) };

  // compute metrics for each
  const list = [shortest,safe,efficient].map(r => {
    const samples = lineSample(r.coords, 80);
    const useCruise = r.cruiseBoost ? cruise + buffer : cruise;
    const s = clearanceStats(samples, useCruise, buffer);
    const distKm = routeDistanceKm(wpsFromCoords(r.coords));
    return { ...r, stats:{ distKm, ...s, cruiseUsed: useCruise } };
  });

  return list;
}

function smoothCoords(coords, alpha=0.3){
  if(coords.length<=2) return coords;
  const out = [coords[0]];
  for(let i=1;i<coords.length-1;i++){
    const a=coords[i-1], b=coords[i], c=coords[i+1];
    out.push([ b[0] + alpha*( (a[0]+c[0])/2 - b[0] ), b[1] + alpha*( (a[1]+c[1])/2 - b[1] ) ]);
  }
  out.push(coords[coords.length-1]);
  return out;
}

function wpsFromCoords(coords){ return coords.map(([lon,lat],i)=>({name:`p${i+1}`,lat,lon})); }



/* -------- Day 4: Parse -------- */
$('btnSample').onclick = ()=>{ $('mission').value = "Fly to mountain lake"; };
$('btnParse').onclick = async () => {
  const btn = $('btnParse');
  if (btn.dataset.busy === '1') return;
  btn.dataset.busy = '1'; btn.textContent = 'Parsing…';
  $('aiOut').textContent = ''; $('validate').textContent = ''; $('advOut').textContent = '';

  try {
    const text = $('mission').value.trim();
    let waypoints = fromTextHeuristics(text);  // raw coords in text

    // Ask backend (OpenAI) for advanced parse
    const r = await fetch('/api/parse', {
      method:'POST', headers:{'Content-Type':'application/json'},
      body: JSON.stringify({ user: text })
    });

    if (r.ok) {
      const { parsed } = await r.json();
      $('advOut').textContent = JSON.stringify(parsed, null, 2);

      // 1) Use any AI targets with coords
      (parsed.targets || []).forEach(t => { if (typeof t.lat === "number" && typeof t.lon === "number") waypoints.push(t); });

      // 2) Geocode name-only targets (cap to first 3 to be polite)
      const nameOnly = (parsed.targets || []).filter(t => t?.name && (t.lat==null || t.lon==null)).slice(0,3);
      const lookups = await Promise.all(nameOnly.map(async t => {
        const q = t.name;
        const g = await fetch(`/api/geocode?q=${encodeURIComponent(q)}`).then(x=>x.json()).catch(()=>({ok:false}));
        return g.ok ? { name: q, lat: g.lat, lon: g.lon } : null;
      }));
      lookups.filter(Boolean).forEach(t => waypoints.push(t));

    } else {
      // Show error but continue with heuristics (raw coords)
      $('advOut').textContent = `OpenAI error → ${await r.text()}\n(using heuristics only)`;
    }

    // Validate + render
    const { ok, msgs } = validateWaypoints(waypoints);
    state.waypoints = ok;
    $('aiOut').textContent = JSON.stringify(ok, null, 2);
    $('validate').innerHTML = (msgs.length? msgs.join('\n') : '✅ Looks good.') + `\nParsed ${ok.length} waypoint(s).`;
    if (ok.length) flyTo(ok[0]);

  } catch (e) {
    $('aiOut').textContent = String(e);
  } finally {
    btn.dataset.busy = '0'; btn.textContent = 'Parse with AI';
  }
};



/* -------- Day 5: Route + safety coloring -------- */
$('btnRoute').onclick = ()=>{
  if(!map) return;
  if(state.waypoints.length<2){
    if(state.waypoints.length===1){
      const p=state.waypoints[0];
      state.waypoints.push({name:"offset",lat:p.lat+0.01,lon:p.lon+0.01});
    }else{ alert('Add at least one waypoint first.'); return; }
  }
  const cruise = parseFloat($('altitude').value)||120;
  const buffer = parseFloat($('buffer').value)||30;

  // build samples and classify
  const coords = state.waypoints.map(wp=>[wp.lon,wp.lat]);
  const samples=60, pts=[];
  for(let i=0;i<samples;i++){
    const t=i/(samples-1);
    const s=t*(coords.length-1); const idx=Math.min(coords.length-2,Math.floor(s));
    const a=coords[idx], b=coords[idx+1], tt=s-idx;
    pts.push([a[0]+(b[0]-a[0])*tt, a[1]+(b[1]-a[1])*tt]);
  }
  const supports = typeof map.queryTerrainElevation==='function' && map.getTerrain();
  const green=[], yellow=[], red=[];
  let minClear=Infinity, bad=0;
  for(let i=0;i<pts.length-1;i++){
    const p=pts[i], q=pts[i+1];
    let elev=0;
    if(supports){ elev = map.queryTerrainElevation({lng:p[0], lat:p[1]}) ?? 0; }
    const clearance = cruise - elev;
    minClear = Math.min(minClear, clearance);
    const seg={type:'Feature',geometry:{type:'LineString',coordinates:[p,q]},properties:{}};
    if(!supports){ green.push(seg); }
    else if(clearance < buffer){ red.push(seg); bad++; }
    else if(clearance < buffer*1.5){ yellow.push(seg); }
    else { green.push(seg); }
  }
  // remove old layers
  for(const id of ['route-green','route-yellow','route-red','route-points']){
    if(map.getLayer(id)) map.removeLayer(id);
    if(map.getSource(id)) map.removeSource(id);
  }
  function addSeg(id, feats, color){
    if(!feats.length) return;
    map.addSource(id,{type:'geojson',data:{type:'FeatureCollection',features:feats}});
    map.addLayer({id, type:'line', source:id, paint:{'line-color':color,'line-width':5}});
  }
  addSeg('route-green', green, '#36d399');
  addSeg('route-yellow', yellow, '#fbbf24');
  addSeg('route-red', red, '#f87171');

  // markers
  const ptsFC = {type:'FeatureCollection',features:state.waypoints.map(w=>({type:'Feature',geometry:{type:'Point',coordinates:[w.lon,w.lat]},properties:{name:w.name}}))};
  map.addSource('route-points',{type:'geojson',data:ptsFC});
  map.addLayer({id:'route-points', type:'circle', source:'route-points',
    paint:{'circle-radius':5,'circle-color':'#4cc3ff','circle-stroke-color':'#001622','circle-stroke-width':2}});

  // UI summary
  if(!supports){
    $('safety').innerHTML = `<span class="warn">Terrain API not active.</span> Route drawn (visual).`;
  }else{
    const status = bad ? `<span class="bad">⚠️ Low-clearance segments: ${bad}/${samples-1}</span>`
                       : `<span class="ok">✅ All segments clear</span>`;
    $('safety').innerHTML = `${status} — Min clearance: ${Math.round(minClear)} m (buffer ${buffer} m)`;
  }
};
</script>
</body>
</html>
