<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>AI Flight Planner — Day 4–5</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <link href="https://unpkg.com/maplibre-gl@3.6.2/dist/maplibre-gl.css" rel="stylesheet" />
  <script src="https://unpkg.com/maplibre-gl@3.6.2/dist/maplibre-gl.js"></script>
  <style>
    :root { --bg:#0e1320; --fg:#e6edf3; --muted:#9fb0c3; --accent:#4cc3ff; }
    *{box-sizing:border-box}
    body{margin:0;font-family:system-ui,Segoe UI,Roboto,Inter;background:var(--bg);color:var(--fg)}
    header{padding:12px 16px;border-bottom:1px solid #1c2333;display:flex;gap:12px;align-items:center}
    header h1{font-size:16px;margin:0;font-weight:600}
    #app{display:grid;grid-template-columns:360px 1fr;min-height:calc(100vh - 50px)}
    #left{border-right:1px solid #1c2333;padding:14px;overflow:auto}
    #right{position:relative}
    #map{position:absolute;inset:0}
    .card{background:#0f172a;border:1px solid #1c2333;border-radius:12px;padding:12px;margin-bottom:12px}
    .row{display:flex;gap:8px;align-items:center;flex-wrap:wrap}
    textarea,input{width:100%;background:#0b1220;color:var(--fg);border:1px solid #1c2333;border-radius:8px;padding:10px}
    button{background:var(--accent);color:#001622;border:0;border-radius:10px;padding:10px 14px;font-weight:600;cursor:pointer}
    button.ghost{background:#0b1220;color:var(--fg);border:1px solid #26324a}
    .small{font-size:12px;color:var(--muted)}
    .kvs{font-family:ui-monospace, Menlo, Consolas, monospace; font-size:12px; white-space:pre-wrap}
    .hr{height:1px;background:#1c2333;margin:10px 0}
    .ok{color:#2ee6a6}.warn{color:#ffb86b}.bad{color:#ff6b6b}
    .badge{position:absolute;right:12px;top:12px;background:#111827c0;padding:6px 10px;border:1px solid #26324a;border-radius:8px}
  </style>
</head>
<body>
<header>
  <h1>AI Flight Planner — Day 4–5</h1>
  <span class="badge" id="demoBadge" style="display:none">Demo mode (cached)</span>
</header>

<div id="app">
  <section id="left">
    <div class="card">
      <strong>Mission Description</strong>
      <textarea id="mission" placeholder="e.g. Fly to mountain lake, then survey the eastern shore at 120m AGL"></textarea>
      <div class="row" style="margin-top:8px">
        <button id="btnParse">Parse with AI</button>
        <button class="ghost" id="btnSample">Use Day-4 Test</button>
      </div>
      <div class="small" style="margin-top:6px">
        Day-4 target: “Fly to mountain lake” → AI extracts coords & a label.
      </div>
      <div class="hr"></div>
      <div><strong>Parsed Output</strong></div>
      <div id="aiOut" class="kvs"></div>
      <div class="hr"></div>
      <div><strong>Validation</strong></div>
      <div id="validate" class="kvs"></div>
    </div>

    <div class="card">
      <strong>Parsed Mission (advanced)</strong>
      <div id="advOut" class="kvs"></div>
    </div>


    <div class="card">
      <strong>Route & Safety</strong>
      <div class="small">With terrain on, we check clearance along the path.</div>
      <div class="row" style="margin-top:8px">
        <input id="altitude" placeholder="Cruise Altitude AGL (m), e.g. 120" />
        <input id="buffer" placeholder="Safety Buffer (m), e.g. 30" />
      </div>
      <div class="row" style="margin-top:8px">
        <button id="btnClick">Click Start/End</button>
        <label class="small"><input type="checkbox" id="chkRTH" checked /> Return to Home</label>
        <button id="btnRoute">Draw Route</button>
      </div>
      <div id="safety" class="small"></div>
    </div>

    <div class="card">
      <strong>Notes</strong>
      <div class="small">
        • OpenAI via backend (key hidden).<br/>
        • MapTiler key restricted by domain; 3D terrain + hillshade + buildings.<br/>
        • Demo fallback when API is unavailable.
      </div>
    </div>
  </section>

  <section id="right"><div id="map"></div></section>
</div>

<script>
const $ = id => document.getElementById(id);
const state = { waypoints: [], config: null };
const SYSTEM_PROMPT = `You extract geographic targets from free-text mission descriptions.
Return strict JSON:
{"targets":[{"name":"label","lat":12.34,"lon":56.78}, ...]}
- If coords not present, infer the single best place.
- Decimal degrees only; lat[-90..90], lon[-180..180].`;

/* -------- boot -------- */
(async function boot(){
  // fetch config (includes map style + whether terrain is enabled)
  const r = await fetch('/api/config');
  state.config = await r.json();
  bootMap();
})();

/* -------- Map -------- */
let map;
function bootMap(){
  const styleUrl = state.config.mapStyleUrl; // already includes key & chosen style
  map = new maplibregl.Map({
    container: 'map',
    style: styleUrl,
    center: [127.0, 37.5], zoom: 6, pitch: 60, bearing: -30
  });
  map.addControl(new maplibregl.NavigationControl(), 'top-right');

  map.on('load', () => {
    if (state.config.terrainDemUrl) {
      if (!map.getSource('terrain')) {
        map.addSource('terrain', { type:'raster-dem', url: state.config.terrainDemUrl, tileSize:256 });
      }
      map.setTerrain({ source:'terrain', exaggeration: 1.5 });

      // hillshade (visual relief)
      if (!map.getLayer('hillshade')) {
        map.addLayer({ id:'hillshade', type:'hillshade', source:'terrain',
          paint:{ 'hillshade-exaggeration': 0.6 } }, undefined);
      }
    }

    // 3D buildings if style exposes OpenMapTiles 'building'
    if (!map.getLayer('3d-buildings')) {
      try {
        map.addLayer({
          id:'3d-buildings',
          type:'fill-extrusion',
          source:'openmaptiles',
          'source-layer':'building',
          minzoom:14,
          paint:{
            'fill-extrusion-color':'#d1d5db',
            'fill-extrusion-height':['coalesce',['get','height'],12],
            'fill-extrusion-base':['coalesce',['get','min_height'],0],
            'fill-extrusion-opacity':0.8
          }
        });
      } catch(_) {/* style may not have openmaptiles; ignore */}
    }
  });
}

let clickMode = false;
let clickPts = []; // [{lat,lon,name}]

$('btnClick').onclick = () => {
  clickMode = !clickMode;
  $('btnClick').textContent = clickMode ? 'Click: ON (choose Start/End)' : 'Click Start/End';
  if (!clickMode) return;
  clickPts = [];
  if (map) {
    map.getCanvas().style.cursor = 'crosshair';
    map.once('click', onClickStart);
  }
};

function onClickStart(e){
  clickPts.push({ name:'Start', lat:e.lngLat.lat, lon:e.lngLat.lng });
  map.once('click', onClickEnd);
}
function onClickEnd(e){
  clickPts.push({ name:'End', lat:e.lngLat.lat, lon:e.lngLat.lng });
  map.getCanvas().style.cursor = '';
  clickMode = false; $('btnClick').textContent = 'Click Start/End';

  // Build waypoints with optional RTH
  const rth = $('chkRTH').checked;
  state.waypoints = rth ? [clickPts[0], clickPts[1], { ...clickPts[0], name:'RTH' }] : [...clickPts];

  // Show in left panel
  $('aiOut').textContent = JSON.stringify(state.waypoints, null, 2);
  $('validate').textContent = '✅ Waypoints from clicks.';
  flyTo(state.waypoints[0]);
}


/* -------- Helpers -------- */
function fromTextHeuristics(s){
  const out=[]; let m;
  const decRe=/([-+]?(\d{1,2}(?:\.\d+)?))\s*[, ]\s*([-+]?(?:1[0-7]\d|\d{1,2})(?:\.\d+)?)/g;
  while((m=decRe.exec(s))!==null){ const lat=+m[1], lon=+m[3]; if(Math.abs(lat)<=90&&Math.abs(lon)<=180) out.push({name:'coord',lat,lon}); }
  const gRe=/@(-?\d{1,2}\.\d+),(-?1?\d{1,2}\.\d+)/g;
  while((m=gRe.exec(s))!==null) out.push({name:'map-link',lat:+m[1],lon:+m[2]});
  const dms=/(\d{1,3})[°\s]\s*(\d{1,2})['\s]\s*(\d{1,2}(?:\.\d+)?)"?\s*([NS])[, ]+\s*(\d{1,3})[°\s]\s*(\d{1,2})['\s]\s*(\d{1,2}(?:\.\d+)?)"?\s*([EW])/ig;
  while((m=dms.exec(s))!==null){
    const lat=(+m[1]+m[2]/60+m[3]/3600)*(m[4].toUpperCase()==='S'?-1:1);
    const lon=(+m[5]+m[6]/60+m[7]/3600)*(m[8].toUpperCase()==='W'?-1:1);
    out.push({name:'dms',lat,lon});
  }
  return out;
}
function validateWaypoints(list){
  const msgs=[], ok=[], seen=new Set();
  for(const p of list||[]){
    const lat=+p.lat, lon=+p.lon;
    if(!Number.isFinite(lat)||!Number.isFinite(lon)){ msgs.push(`❌ Non-numeric: ${JSON.stringify(p)}`); continue; }
    if(Math.abs(lat)>90||Math.abs(lon)>180){ msgs.push(`❌ Out of range: ${lat}, ${lon}`); continue; }
    const key=lat.toFixed(6)+","+lon.toFixed(6);
    if(seen.has(key)){ msgs.push(`⚠️ Duplicate ignored: ${key}`); continue; }
    seen.add(key); ok.push({name:p.name||"wp",lat,lon});
  }
  return {ok,msgs};
}
function flyTo(p){ map && map.flyTo({center:[p.lon,p.lat], zoom: 10}); }

/* -------- Backend call with retry -------- */
async function callParseAPI(payload, maxRetries=2){
  let attempt=0;
  while(true){
    const r = await fetch('/api/parse', {
      method:'POST', headers:{'Content-Type':'application/json'},
      body: JSON.stringify(payload)
    });
    if(r.status!==429) return r;
    attempt++; if(attempt>maxRetries) return r;
    const retryAfter=parseFloat(r.headers.get('retry-after')||'0');
    await new Promise(res=>setTimeout(res, (retryAfter?retryAfter*1000:1500*attempt)));
  }
}

/* -------- Day 4: Parse -------- */
$('btnSample').onclick = ()=>{ $('mission').value = "Fly to mountain lake"; };
$('btnParse').onclick = async () => {
  const btn = $('btnParse');
  if (btn.dataset.busy === '1') return;
  btn.dataset.busy = '1'; btn.textContent = 'Parsing…';
  $('aiOut').textContent = ''; $('validate').textContent = ''; $('advOut').textContent = '';

  try {
    const text = $('mission').value.trim();
    let waypoints = fromTextHeuristics(text);  // raw coords in text

    // Ask backend (OpenAI) for advanced parse
    const r = await fetch('/api/parse', {
      method:'POST', headers:{'Content-Type':'application/json'},
      body: JSON.stringify({ user: text })
    });

    if (r.ok) {
      const { parsed } = await r.json();
      $('advOut').textContent = JSON.stringify(parsed, null, 2);

      // 1) Use any AI targets with coords
      (parsed.targets || []).forEach(t => { if (typeof t.lat === "number" && typeof t.lon === "number") waypoints.push(t); });

      // 2) Geocode name-only targets (cap to first 3 to be polite)
      const nameOnly = (parsed.targets || []).filter(t => t?.name && (t.lat==null || t.lon==null)).slice(0,3);
      const lookups = await Promise.all(nameOnly.map(async t => {
        const q = t.name;
        const g = await fetch(`/api/geocode?q=${encodeURIComponent(q)}`).then(x=>x.json()).catch(()=>({ok:false}));
        return g.ok ? { name: q, lat: g.lat, lon: g.lon } : null;
      }));
      lookups.filter(Boolean).forEach(t => waypoints.push(t));

    } else {
      // Show error but continue with heuristics (raw coords)
      $('advOut').textContent = `OpenAI error → ${await r.text()}\n(using heuristics only)`;
    }

    // Validate + render
    const { ok, msgs } = validateWaypoints(waypoints);
    state.waypoints = ok;
    $('aiOut').textContent = JSON.stringify(ok, null, 2);
    $('validate').innerHTML = (msgs.length? msgs.join('\n') : '✅ Looks good.') + `\nParsed ${ok.length} waypoint(s).`;
    if (ok.length) flyTo(ok[0]);

  } catch (e) {
    $('aiOut').textContent = String(e);
  } finally {
    btn.dataset.busy = '0'; btn.textContent = 'Parse with AI';
  }
};



/* -------- Day 5: Route + safety coloring -------- */
$('btnRoute').onclick = ()=>{
  if(!map) return;
  if(state.waypoints.length<2){
    if(state.waypoints.length===1){
      const p=state.waypoints[0];
      state.waypoints.push({name:"offset",lat:p.lat+0.01,lon:p.lon+0.01});
    }else{ alert('Add at least one waypoint first.'); return; }
  }
  const cruise = parseFloat($('altitude').value)||120;
  const buffer = parseFloat($('buffer').value)||30;

  // build samples and classify
  const coords = state.waypoints.map(wp=>[wp.lon,wp.lat]);
  const samples=60, pts=[];
  for(let i=0;i<samples;i++){
    const t=i/(samples-1);
    const s=t*(coords.length-1); const idx=Math.min(coords.length-2,Math.floor(s));
    const a=coords[idx], b=coords[idx+1], tt=s-idx;
    pts.push([a[0]+(b[0]-a[0])*tt, a[1]+(b[1]-a[1])*tt]);
  }
  const supports = typeof map.queryTerrainElevation==='function' && map.getTerrain();
  const green=[], yellow=[], red=[];
  let minClear=Infinity, bad=0;
  for(let i=0;i<pts.length-1;i++){
    const p=pts[i], q=pts[i+1];
    let elev=0;
    if(supports){ elev = map.queryTerrainElevation({lng:p[0], lat:p[1]}) ?? 0; }
    const clearance = cruise - elev;
    minClear = Math.min(minClear, clearance);
    const seg={type:'Feature',geometry:{type:'LineString',coordinates:[p,q]},properties:{}};
    if(!supports){ green.push(seg); }
    else if(clearance < buffer){ red.push(seg); bad++; }
    else if(clearance < buffer*1.5){ yellow.push(seg); }
    else { green.push(seg); }
  }
  // remove old layers
  for(const id of ['route-green','route-yellow','route-red','route-points']){
    if(map.getLayer(id)) map.removeLayer(id);
    if(map.getSource(id)) map.removeSource(id);
  }
  function addSeg(id, feats, color){
    if(!feats.length) return;
    map.addSource(id,{type:'geojson',data:{type:'FeatureCollection',features:feats}});
    map.addLayer({id, type:'line', source:id, paint:{'line-color':color,'line-width':5}});
  }
  addSeg('route-green', green, '#36d399');
  addSeg('route-yellow', yellow, '#fbbf24');
  addSeg('route-red', red, '#f87171');

  // markers
  const ptsFC = {type:'FeatureCollection',features:state.waypoints.map(w=>({type:'Feature',geometry:{type:'Point',coordinates:[w.lon,w.lat]},properties:{name:w.name}}))};
  map.addSource('route-points',{type:'geojson',data:ptsFC});
  map.addLayer({id:'route-points', type:'circle', source:'route-points',
    paint:{'circle-radius':5,'circle-color':'#4cc3ff','circle-stroke-color':'#001622','circle-stroke-width':2}});

  // UI summary
  if(!supports){
    $('safety').innerHTML = `<span class="warn">Terrain API not active.</span> Route drawn (visual).`;
  }else{
    const status = bad ? `<span class="bad">⚠️ Low-clearance segments: ${bad}/${samples-1}</span>`
                       : `<span class="ok">✅ All segments clear</span>`;
    $('safety').innerHTML = `${status} — Min clearance: ${Math.round(minClear)} m (buffer ${buffer} m)`;
  }
};
</script>
</body>
</html>
